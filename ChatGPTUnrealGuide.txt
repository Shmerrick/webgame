Great news: you don’t need to “rewrite everything in Unreal.” The clean way is to treat your existing C++ as an engine-agnostic **core** and add a thin Unreal wrapper around it.

Below is a practical path that works well on UE5 (5.0–5.4):

# 0) Decide your integration style

**A. Keep your logic as a separate library (recommended)**

* Build your game logic as a static lib (or DLL) per platform.
* Add it to UE as a **Third-Party** module and write a small **Runtime** wrapper module that exposes it to Actors/Components/Blueprints.

**B. Pull your source files directly into a UE module**

* Simpler build, but you’ll adapt more to Unreal types/macros and give up a clean engine boundary.

I’ll show A (library) first, then notes for B.

---

# 1) Prepare your core library

* Make the core update via a **`Game::Update(float dt)`** (no own main loop).
* Remove any direct rendering/audio/input—those will be driven by Unreal.
* Keep STL if you want; Unreal can compile with it. If you use exceptions/RTTI, just enable them in the UE module (off by default).
* If you use glm/Eigen/etc., keep them. You’ll add tiny converters to Unreal’s `FVector`/`FRotator` when needed.

Build your lib for each target (e.g., Win64 `.lib`, Mac `.a`, Linux `.a`) using the **same compiler toolchain** version that ships with your UE installation to avoid ABI/CRT mismatches.

---

# 2) Create a UE plugin with two modules

```
YourProject/
└─ Plugins/
   └─ MyGameCore/
      ├─ MyGameCore.uplugin
      ├─ Source/
      │  ├─ MyCore/                (ModuleType=External; the “Third-Party” module)
      │  │  └─ MyCore.Build.cs
      │  └─ MyGameCoreRuntime/     (Runtime module; your Unreal wrappers)
      │     ├─ MyGameCoreRuntime.Build.cs
      │     ├─ Public/
      │     └─ Private/
      └─ ThirdParty/
         └─ MyCore/
            ├─ include/            (public headers of your core)
            └─ lib/
               ├─ Win64/MyCore.lib
               ├─ Mac/libMyCore.a
               └─ Linux/libMyCore.a
```

**`MyCore.Build.cs`** (External/Third-Party module):

```csharp
using UnrealBuildTool;
using System.IO;

public class MyCore : ModuleRules
{
    public MyCore(ReadOnlyTargetRules Target) : base(Target)
    {
        Type = ModuleType.External;

        string Root = Path.Combine(ModuleDirectory, "..", "..", "ThirdParty", "MyCore");
        PublicIncludePaths.Add(Path.Combine(Root, "include"));

        // Enable if your core uses them
        bEnableExceptions = true;   // default false in UE
        bUseRTTI = true;            // default false in UE
        CppStandard = CppStandardVersion.Cpp20;

        if (Target.Platform == UnrealTargetPlatform.Win64)
        {
            PublicAdditionalLibraries.Add(Path.Combine(Root, "lib", "Win64", "MyCore.lib"));
        }
        else if (Target.Platform == UnrealTargetPlatform.Mac)
        {
            PublicAdditionalLibraries.Add(Path.Combine(Root, "lib", "Mac", "libMyCore.a"));
        }
        else if (Target.Platform == UnrealTargetPlatform.Linux)
        {
            PublicAdditionalLibraries.Add(Path.Combine(Root, "lib", "Linux", "libMyCore.a"));
        }
    }
}
```

**`MyGameCoreRuntime.Build.cs`** (your wrapper):

```csharp
using UnrealBuildTool;

public class MyGameCoreRuntime : ModuleRules
{
    public MyGameCoreRuntime(ReadOnlyTargetRules Target) : base(Target)
    {
        PublicDependencyModuleNames.AddRange(new string[] {
            "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput"
        });

        // Link the Third-Party module
        PrivateDependencyModuleNames.Add("MyCore");

        // Match your core’s needs
        bEnableExceptions = true;
        bUseRTTI = true;
        CppStandard = CppStandardVersion.Cpp20;
    }
}
```

**`MyGameCore.uplugin`** (minimal):

```json
{
  "FileVersion": 3,
  "VersionName": "1.0",
  "FriendlyName": "MyGameCore",
  "Category": "Gameplay",
  "Modules": [
    { "Name": "MyCore", "Type": "Runtime", "LoadingPhase": "Default" },
    { "Name": "MyGameCoreRuntime", "Type": "Runtime", "LoadingPhase": "Default" }
  ]
}
```

---

# 3) Write a tiny Unreal wrapper

A simple approach is a **Component** that owns your core and ticks it:

**`UGameLogicComponent.h`**

```cpp
#pragma once
#include "Components/ActorComponent.h"
#include "GameLogicComponent.generated.h"

namespace mycore { class Game; }

UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class MYGAMECORERUNTIME_API UGameLogicComponent : public UActorComponent
{
    GENERATED_BODY()
public:
    UGameLogicComponent();

    virtual void BeginPlay() override;
    virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;
    virtual void TickComponent(float DeltaTime, ELevelTick TickType,
        FActorComponentTickFunction* ThisTickFunction) override;

    // Example input hooks your Controller/Pawn can call:
    UFUNCTION(BlueprintCallable) void OnMove(const FVector2D& Axis);
    UFUNCTION(BlueprintCallable) void OnFire();

private:
    TUniquePtr<mycore::Game> Game; // not a UObject, so no UPROPERTY
};
```

**`UGameLogicComponent.cpp`**

```cpp
#include "GameLogicComponent.h"
#include "Engine/World.h"

// Include your core header from ThirdParty/include
#include "MyCore/Game.hpp"

UGameLogicComponent::UGameLogicComponent()
{
    PrimaryComponentTick.bCanEverTick = true;
}

void UGameLogicComponent::BeginPlay()
{
    Super::BeginPlay();
    Game = MakeUnique<mycore::Game>();
    // Initialize with any needed parameters from UE world/actors
}

void UGameLogicComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
    Game.Reset();
    Super::EndPlay(EndPlayReason);
}

void UGameLogicComponent::TickComponent(float Dt, ELevelTick, FActorComponentTickFunction*)
{
    if (Game) Game->Update(Dt);
}

void UGameLogicComponent::OnMove(const FVector2D& Axis)
{
    if (Game) Game->InputMove(Axis.X, Axis.Y);
}

void UGameLogicComponent::OnFire()
{
    if (Game) Game->InputFire();
}
```

Attach this component to your Pawn/Character (or a manager Actor). In your **PlayerController/Pawn**, bind Enhanced Input actions and forward them to the component (or expose BlueprintCallable methods like above).

---

# 4) Map UE systems to your core

* **Time:** pass `DeltaTime` via tick (above).
* **Input:** use **Enhanced Input** (`UInputAction`) and call component methods.
* **Transforms/Math:** add tiny adapters between your math types and Unreal’s:

  ```cpp
  static FORCEINLINE FVector ToUE(const glm::vec3& v){ return FVector(v.x, v.y, v.z); }
  static FORCEINLINE glm::vec3 ToGLM(const FVector& v){ return glm::vec3(v.X, v.Y, v.Z); }
  ```
* **Physics/Collision:** listen to overlap/hit events (`OnComponentBeginOverlap`, `OnHit`) and notify the core; or let UE drive physics and only keep gameplay state in the core.
* **Networking:** if you need replication, keep your core deterministic. Wrap state in a `UActorComponent` with `UPROPERTY(Replicated)` fields and RPCs (`UFUNCTION(Server, Reliable)`, `UFUNCTION(NetMulticast, …)`) that apply inputs and broadcast results. The core itself stays engine-agnostic.

---

# 5) Common gotchas (and fixes)

* **Exceptions/RTTI:** disabled by default in UE modules. Turn on per module where needed (`bEnableExceptions = true; bUseRTTI = true;`).
* **CRT/Toolchain mismatch (Windows):** ensure both your core and UE use the same MSVC toolset and runtime (/MD). Mixing DLL boundaries with different CRTs can crash on allocation across the boundary.
* **Threads:** only touch UObjects/Actors on the **game thread**. If your core runs worker threads, marshal results back via `AsyncTask(ENamedThreads::GameThread, []{ … })`.
* **Memory/GC:** your core types aren’t UObjects—manage them with `std::unique_ptr`/`TUniquePtr`. If you create UObjects, do it with `NewObject<>()` and keep references in `UPROPERTY()` so the GC sees them.
* **Build flags:** match `CppStandard` to what your core expects (C++17/20).
* **Packaging:** ship the right `.lib/.a/.dll/.dylib` per platform and configuration (Debug/Development/Shipping) in your plugin.

---

# 6) If you prefer “drop source into Unreal” (Style B)

* Create a **Runtime** module (no External module).
* Put your core headers/sources under `Source/MyGameCoreRuntime/Public|Private`.
* In `Build.cs`, set the flags (exceptions/RTTI/CppStandard) your code needs.
* Optionally, isolate engine-specific code behind small adapter classes so you can still build the core outside UE with CMake when you want (same files, different build).

---

# 7) Minimal checklist

1. Make your core step-driven (`Update(dt)`), no global loop.
2. Build per-platform libs (or import sources).
3. Create a UE plugin with:

   * External **MyCore** (Third-Party) module (includes + libs)
   * **MyGameCoreRuntime** wrapper module (depends on MyCore)
4. Add a **UGameLogicComponent** that owns and ticks the core.
5. Forward input/physics/network events to the core.
6. Package with the right binaries per target.

---